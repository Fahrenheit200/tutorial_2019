## 任务：项目考核（嵌入式与控制方向）

### 表头信息

- 作者: 雷发兴
- 修订: 雷发兴
- 日期: 2019年11月02日
- 版本: 1.0.0
- 摘要: 基于 STC12c5a60s2 单片机实现简易音乐播放器，基于 Arduino UNO 实现大数相加
- 硬件资源：两块 STC12c5a60s2 单片机，两块 0.96 寸 OLED 显示屏，一个无源蜂鸣器，四个按键， 杜邦线若干，Arduino UNO 一块，SD卡卡座一块。
- 开发环境: Keil4，Arduino IDE，python3.0。

### 任务完成情况

| 已完成部分                                   | 
| ----------------------------                 | 
| 通过蜂鸣器播放音乐                           | 
| OLED 交互界面                                | 
| 按键控制乐曲播放以及按键控制音乐频谱图案类型 | 
| 显示音乐动态频谱                             | 
| 上位机 GUI 界面查看播放器中已储存的音乐      | 
| 大数相加                                     |

###项目思路

####通过蜂鸣器播放音乐以及按键交互       
    音乐以音调加节拍的形式储存，每首歌有一个音调数组和一个节拍数组，曲谱存贮格式 unsigned char code MusicNote{音高，音高，...., 0xff}; 末尾:0xff 表示结束；unsigned char code MusicBeat{音长，音长，...., }; 在音调表中，数字 1-7 表示低音，8-14 表示中音，15-21 表示高音；
在节拍表中，数字 4 表示四分音符，1 表示十六分音符，2 表示八分音符，以此类推，关于音调和节拍的确定方法参阅了百度上一篇文章：[简谱入门-怎么看](https://jingyan.baidu.com/article/0bc808fc9f0cf61bd485b9cf.html?_wv=5)。每一个音符对应一个频率，然后通过单片机的定时器定时中断，将单片机上对应蜂鸣器的I/O口来回取反，或者说来回清零，置位，从而让蜂鸣器发出声音，为了让单片机发出不同频率的声音，我们只需将定时器予置不同的定时值就可实现。注意需要使用无源蜂鸣器，我们使用 STC12c5a 单片机的 T0 定时器来产生不同频率。在按键交互部分，我们使用 T1 定时器进行消抖。为了实现按键交互，我们声明两个指针分别指向音调数组和节拍数组，然后声明一个整型变量 `Num` 用来表示当前在播放的歌曲，通过按键控制 `Num` 增加或减少搭配 `switch` 语句便可实现上一曲，下一曲等功能，另外在动态频谱部分有一个特殊按键，详述见后。我们一共在音乐播放器中储存了十首歌曲。

#### OLED交互
    OLED 交互部分使用了网上 OLED 例程的一些接口，包括显示字符，字符串等，相关接口函数详见 `oled.h` 头文件，压缩包 `Music_Player.zip` 中包含了OLED交互和按键交互部分，该工程文件实现了音乐播放器的基础功能，需要一块 STC12c5a 单片机，将该工程中的 `hex` 文件烧入单片机中即可。

#### 显示音乐动态频谱 
    动态频谱最开始是想用 LCD1602 模块实现，但后来感觉用 OLED 效果会好一些，所以使用了 0.96寸 OLED显示屏来实现。动态频谱需要另一块 STC12c5a 单片机，该部分主要分为三个步骤，AD模块采集数据，FFT快速傅立叶变换得出频率信息，OLED 显示函数绘制出动态频谱。STC12c5a 芯片内置 AD 模块，相关引脚为 P1,我们通过 P1^0 采集信号，然后用调用FFT函数进行变换。显示函数一共有6个，从`showbar0()`到`showbar5()`,分别对应不同的条形柱图样，通过按键4来切换。在使用动态频谱时，只需将蜂鸣器的数据输入信号线接到动态频谱单片机的P1^0引脚即可。动态频谱部分的工程文件存放在压缩包 `OLED_Dynamic_Spectrum.zip` 中。

#### 上位机通信
    上位机程序使用 python3.0 编写，有一个简易的 GUI 界面，可实现与单片机通信，包括接收和发送数据，通过上位机可查看音乐播放器中的歌曲名，也可向单片机中下载歌曲简谱，但因为我选用的是 STC12c5a 最小系统版，属于 51 单片机系列，在下载部分遇到了以下问题，上位机通过串口发送给单片机的歌曲简谱，是储存在 RAM 储存空间中，一旦单片机断电， 接收到的简谱数据便会消失，因此需要在把 RAM 中的歌曲简谱数据写入到 EEPROM 中，但这一步难度较大，在尝试很多次后，放弃这个方法。后来我想到了另一个办法，将下载到 RAM 中的歌曲简谱，写入到 SD 卡中作为 `.txt` 文件保存，结果还是因为选择了51单片机的缘故，遇到了相当大的阻碍，主要是51单片机实现 SD 卡的文件读写操作需要实现 FAT32 文件系统，因为考虑到大数相加部分也要读写 SD 卡，所以尝试了一天，结果感觉在 51 单片机上实现 FAT32 文件系统的难度相较于 EEPROM 有过之而无不及，最终失败，大数相加也放弃使用 51 单片机实现，转而使用 Arduino UNO 进行 SD 卡读写。上位机部分的工程代码存放在压缩包 `Serial_Com_and_GUI.zip` 中。

#### 大数相加与 SD 卡读写
    大数相加部分的重点应该是对 SD 卡的读写吧，因为我最开始是考虑使用 51 单片机实现该部分，所以查阅了大量有关 51 单片机 SPI通信模式和实现 FAT32 文件系统的资料，也做了许多尝试，在网上找了一个叫 znFat 的文件系统操作通用库，想要把它移植到 STC12c5a60s2 上，相关工程代码存放在压缩包 `SD_fat32_uart.zip` 中。后来因为时间不够，而且还有很多作业没写（过于真实/捂脸），所以转而用了 Arduino UNO，基本算法是模拟全加器，向 `a.txt` 和 `b.txt`两个文件中逆序逐个读取字符，然后转换为数字进行相加，分别保留相加结果的余数和进位，把余数写入到一个临时的 `tenpfile.txt`文件中，进位与下一次读取得到的余数相加，不断循环此过程，直到读取到一个文件的开头，然后把另一个较长文件的剩余数据逆序全部写到 `tempfile.txt`文件中，最后将文件 `tempfile.txt` 逆序，就得到了结果 `sum.txt`。注意到这种算法运行效率不高，如果要缩短计算时间，可以考虑一次读取 50 或 100 个数据进行相加。然后，因为实在是要赶作业，所以大数相乘没时间写了。
    



